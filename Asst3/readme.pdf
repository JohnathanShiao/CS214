ds1576
ml1417
-------------------------------------------------------------------------------------------------
Socket Programming:
Server Set-Up:
-The first step to create a client/server model is to create a server socket since all client sockets have to connect to said server socket.
-We created a socket server by getting a socket descriptor from socket(). Then, we set up the socket with the SO_REUSEPORT socket option to allow multiple sockets on the same host to bind to the same port (intended to improve the performance of multithreaded network server applications). Once we have the socket descriptor, we bind it to the port that is given as an argument from the user. We listen for any incoming connections, and with this step and the step prior, we check if there are any errors that occur and send error if there are any. If successful, the next step is to accept any incoming clients and then create a thread to handle the action that the client requests (go to multithreading for more information on the threading aspect of the design).           
Client Set-Up:
-Since the client is also a socket, the steps are similar to the server set-up. To create a client socket, we first get a socket descriptor from socket(). Then, we connect the socket to the server using IP address/hostname and port number (should match the server port number) which are given by the user as arguments for the configure command. We check the status of the connection, and if the connection is not established, we will send an error to the user. This is usually of an invalid hostname/IP or different port number from the server.
Note: the server socket must be established (i.e. the executable ./WTFserver must be running prior to the establishment of client(s) (i.e. running the ./WTF executable)
-------------------------------------------------------------------------------------------------
Manifest:
-Since the manifest is the metadata for each project, we created a struct that would allow for easier manipulation. The manifest struct has the fields: int version, char* projectname, file** files which are the project's version number, name, and hash table of files respectively.
-The file struct has its own version number, name, digest, and file pointer to the next file. The pointer is used in creating the hash table of the files per project for worst case time complexity O(n) in search, insertion, and deletion of files. This is beneficial for changing files in the project.
-The digest of the file represents the file's contents that is used to compare to the contents of two files. We decided to use SHA-1 hash function to get the digest of a given file. The getDigest function takes in the file name as the parameter. Given the file name, we open that file and read that that file and utilize the provided SHA-1 initialization and update functions. Once the entire file is read, we finalize the SHA-1 hash.
-The hash table's hash function is the (ascii value of the file's name) mod number of entries
-Functions involving manifest: (their uses to be explained in procedure)
o   initManifest() mallocs space for a manifest struct
o   createManifestFile() creates a .Manifest file from a given manifest struct. The file contains the manifest version number followed by the files and their versions and digest
o   deleteFromManifest() deletes as given file from the manifest struct's hash table of files
o   updateManifest() updates the digest by calling getDigest on the file given that the file has been modified and increments the version number of the file
o   insertToManifest() inserts a file to the manifest's hash table of files
o   loadManifest() creates a manifest struct given a manifest file
o   freeManifest() frees the given manifest struct
-------------------------------------------------------------------------------------------------
Procedure:

Client:
The client.c program deals with taking in commands from the user. The program expects either 3 or 4 arguments depending on the command. Prior to any action done, the user must configure to the server by providing its IP Address/hostname along with the port number of the server. This command will save the information in a .configure file, so the user does not have to have to reinput it with the commands following.
-Once configuration is completed, the user may do a number of actions by with the command lines ./WTF <action> <project name>. Therefore, the program expects 3 arguments in dealing with the following project commands: create, destroy, currentversion, checkout, update, upgrade, history, push, and commit. If the number of arguments is not 3 or argv[1] is not one of these commands, there is error. If the command is valid, then the program will initialize a network socket, using the initSocket() function. This function streamlines the program as it does not include repetitions of a socket initialization per each condition of command. The initSocket() function also checks for errors connecting to the server for when there is an invalid IP/hostname or port number.
-Once there is a successful creation of network socket connected with the server, the program then calls a respective function to execute the intended command. The functions are denoted by "client_<command>" and take the parameters of the project name (given as argv[2]) and the initialized network socket descriptor. Each function will write to the server a three letter code that indicates the command they are executing and will expect to receive confirmation of a digit from the server using read.
-Now we will examine the functions and their design:
Client_creat:
Sends the message CRT~#bytes~name to the server and indicates that the client has written to the server with a print statement. The server is expected to send back '0' to indicate that the project is not already in existence, so the program will create a directory named the project name and a .Manifest file in that directory. If the server indicates that the project already exists by sending back a nonzero number, then there will be a print statement that tells the user this.
Client_des:
Sends the message DES~#bytes~name to the server and expects either a 0 or nonzero digit message from the server. If the server sends back a '0', then the project does not exist on the server, and this is an error. If there is a nonzero digit received, then the project was destroyed. Either result will be indicated to the user via a print statement.
Client_ver:
Sends the message VER~#bytes~name to the server and expects a nonzero digit message from the server. If the received message is a '1', then the client will output a list of all files under the project name, along with their version number, as long as there is no error reading from the socket. If the receive message is a '2', then there was an error that no .Manifest was found for the project. Any other digit indicates that there was no project found with the given name.
Client_check:
The function will first check if the project exists on its side. If the project already exists locally on the client side, then there will be an error printed. If the project does not exist on the client side, then it will send a CHK~#bytes~name to the server. If the server sends back a '1', then the project was found on the server. The client will then read from the socket which the server has sent the project and will make the project directory on its side. This will be done with creating a .Manifest file and recreate it by initializing all the necessary directories and read each file's data. If the server sends back a '2', then there was not .Manifest file found for the given project. If server receives any other digit, then the server does not have the indicated project.
Client_update:
The function will first check if the project exists locally on the client side. If the project does not exist locally, then there is an error. If the project is found, then the function will read the projects directory and send the message UPD~#bytes~name to the server. If the server writes back a '1', then the client can receive the updated project from the server. The clients will then load up an initialized manifest struct with all the information from the server such as version number and the hash table of files. Then the client will load up the client-side version of the .Manifest file with manifest struct's information. There can be an error where the local manifest does not exist which will be indicated via print statement. If there is no errors thus far, then the client will compare the two manifest structs using manifestDifference(), and if there are conflicts found, this will be indicated to the user. If the server writes back '2', then the .Manifest file was not found for the project on the server. If the server writes back a '3', then the .Manifest file on the server for the project is empty. If the server writes back any other digit, then the project does not exist on the server side. If the project is empty on the client side, this is also an error. All errors will be printed to the user.
Client_upgrade:
First the function will check if the project exists locally. If it does not, then there is an error since it cannot be upgraded if it does not exist. Otherwise the procedure is as follows. The function will check it .Conflict file exist, and if there are conflicts, then there will be a print statement to resolve the conflicts and update. If not, then the function will check for if .Update exists. If not, the user is told to run the update command on the project first. After these two checks are successful, then it will send UPG~#bytes~name to the server. If the server sends '1' back, then we know the project exists on the server, and we can read all files. For each file, we will check if it is up to date, and if all files are up to date then the program will return. Otherwise, the function loads up a manifest struct based off the local .Manifest file for the project. If the .Manifest file was empty, then this will be indicated as an error. Otherwise, to upgrade, the manifest struct will be manipulated using insert, delete, and update manifest struct functions. Then the .Manifest file will be created based on the upgraded manifest struct using createManifestFile(). If the server sends back '2', then the .Manifest file for the project on the server side was not found. If the server sends back a '3', then the .Manifest file for the project on the server side was empty. If the server sends any other number, then the project does not exist on the server.
Client_commit:
First the function will check if the project exists. If the project does not exist locally, then this is an error which will be printed to the user. If the project does exist, then the function goes to check the project's .Conflict file. If there exists conflicts, this is an error. Otherwise, the function will go on to check .Update file, and if there exists pending updates, this is an error printed to the user. Once the project passes these checks, the client will write to the server socket COM~#bytes~name. If the server writes back a '1', then the function will load up the server's manifest to compare with the client's manifest using clientDifference. If there exists differences, then we remove <project>/.Commit file for the project. Commit is successful. If the server sends back a '2', '3' or other digit, then there are errors that indicate the server does not have a .Manifest for the project, the .Manifest file is empty, or the project does not exist on the servers respectively.
PUSH:
HISTORY:
-There are other commands that require more parameters, so we also will be looking for command from the user that take the form ./WTF <action> <project name> <additional>. These commands are add, remove, and rollback (not including configure as we have already covered configure previously). If the number of arguments is not 4, argv[1] is not one of these commands, argv[2] and argv[3] are not valid, then there is error. Based on the command from argv[1], then a respective function is also called. This is similar to the previous functionality, but a socket is not necessary for add or remove since these actions take place locally. Rollback requires a network socket as it is accessing the server.
-Now we will examine these commands:
Add:
First checks if the project exists already. If it doesn't, then this is an error. Otherwise, the function checks if the project is empty, and if the project is empty, then then is an error. Otherwise, we check if the file exists. If not, this is an error. If the file does exist, then we access the project's .Manifest file. We check if the .Manifest is empty or has an existing file with the same name, which will indicate as an error and warning respectively. If the file passes these checks, then it is added to the project's .Manifest file successfully.
Rem:
First checks if the project exists already. If it doesn't, then this is an error. Otherwise, the function checks if the project is empty, and if the project is empty, then then is an error. Otherwise, we find the path to the file and the path to the .Manifest file of the project. We check if the .Manifest file exists for the project, and if it doesn't then this is an error. If this is not the case, then the function will load a manifest struct with the information provided from the .Manifest file. We will then delete the corresponding file from the manifest struct using deleteFromManifest. Once this is completed, we recreate the .Manifest file using the manifest struct using createManifestFile.
ROLLBACK:

-------------------------------------------------------------------------------------------------
Procedure:
Server:
The server.c program maintains the server's repository which multiple clients are able to access. Running its executable ./WTFserver only requires the port number to listen and the command line should take format ./WTFserver <port number>. Therefore, the program expects for 2 arguments, so if this is not the case, then this is an error. If the port number is less than 1024, then this is invalid. Otherwise, the server will create a server socket (as discussed in the socket programming section). Once the server accepts a client, a thread is created to deal with that client, and the server goes back to accepting. This ensures that any client communication will not be in the same execution context that listens for new connections. For each thread, the server waits for the client to write the 3 letter code to indicate its wanted action from the server. The server then calls the function that is associated with the code. Some commands utilize the same function to streamline the code as some commands ask for the same information from the server side, but the client is the side with a separate execution. All the functions take the client socket file descriptor as a parameter and do send as needed to the client. This will be in the form of digits as indication of status of files/projects on the server and as well the contents necessary for the client to execute the command. The functions are denoted as "serv_<command>".
-   	The function utilizes the clientMessage function that takes in the client socket descriptor and then returns the project name that information is needed about.
-   	Now we will examine the functions and their design:
Serv_creat: for client code CRT
The function will check if the name is present on the server. If it already exists, the server will write back a '1'. Otherwise, the client will write back to the client a '0'. Then the server will create a directory with the project's name and create a .Manifest file.
Serv_del: for client code DES
The function will check if the name is present on the server. If it is not, then the server will write to the client a '0'. Otherwise, the server will send a '1' and recursively delete all the files of the project and then the project directory itself.
Serv_ver: for client codes VER, UPD, COM
The function will look up the file if it exists on the server. If it is not, then the server will write back to the client a '0'. Otherwise, it will open the .Manifest file of the project (send '2' to client on error that it is not found) and load a manifest struct with the information from the file. If the .Manifest file is empty, then the server will send a '3' to indicate error. Otherwise, the server will write '1' to indicate success and then write the manifest struct's information to the client for the client to use accordingly.
Serv_check: for client codes CHK
The function will first check if the project exists, and if it does not, then writes to the client a '0' to indicate error. Then, will load a manifest struct with all the information of the .Manifest file ('2' sent to client if the .Manifest doesn't exist). Otherwise, the server will write a '1' to the client to indicate success. It will then write the version to the client and then the files' information for the client to use. Then it will indicate that the files are being sent with a print statement and write the all the project's file (writeFile) to the client to use.

Serv_upgrade: for client code UPG
The function will first check if the project exists, and if it does not, then writes to the client a '0' to indicate error. Then, will load a manifest struct with all the information of the .Manifest file ('2' sent to client if the .Manifest doesn't exist). If the .Manifest file exists, then the function will write the version number of the manifest and all the files of the project (using writeFile) for the client to use.

-------------------------------------------------------------------------------------------------
Multithreading:
-As the server should be able to handle multiple clients at a time, we implemented multithreading. The threads' creation occurs in the server.c file.
-We have a handle_connection function that deals with the client's message (which is the command they request from the server), and initially we implemented a top-bottom design for only a single client. The server accepts the client and then the client descriptor is passed to the handle_connection, where the server figures of the command desired and executes it for the client and then sends back a confirmation to the client on whether it was successful or unsuccessful.
- This implementation of the connection handler makes multithreading simple. Upon accept of one client, we create a thread to deal with it, and then go back to accepting the next client... and so on.
-The handle_connection function is a void*/void* function, so we can use pthread_create() to create a thread to deal with whichever client.
 
-------------------------------------------------------------------------------------------------
Thread Synchronization:
-Since there can be multiple clients (i.e. multiple threads) on the server at once, the program will create a mutex for each project to control access to them.
	Mutexes:
To prevent deadlocks...
 
